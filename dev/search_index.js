var documenterSearchIndex = {"docs":
[{"location":"api/#Exported-functions-and-types","page":"API","title":"Exported functions and types","text":"","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Docstrings","page":"API","title":"Docstrings","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [ControlSystemsMTK]\nPrivate = false","category":"page"},{"location":"api/#ModelingToolkit.ODESystem-Tuple{AbstractStateSpace}","page":"API","title":"ModelingToolkit.ODESystem","text":"ModelingToolkit.ODESystem(sys::AbstractStateSpace; name::Symbol, x0 = zeros(sys.nx), x_names, u_names, y_names)\n\nCreate an ODESystem from sys::StateSpace. \n\nArguments:\n\nsys: An instance of StateSpace or NamedStateSpace.\nname: A symbol giving the system a unique name.\nx0: Initial state\n\nThe arguments below are automatically set if the system is a NamedStateSpace.\n\nx_names: A vector of symbols with state names. \nu_names: A vector of symbols with input names. \ny_names: A vector of symbols with output names. \n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemsBase.feedback-Tuple{T} where T<:AbstractTimeDependentSystem","page":"API","title":"ControlSystemsBase.feedback","text":"G = ControlSystemsBase.feedback(loopgain::T; name)\n\nForm the feedback-interconnection G = L(1+L)\n\nThe system G will be a new system with input and output connectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemsMTK.GainScheduledStateSpace-Tuple{Any, Any}","page":"API","title":"ControlSystemsMTK.GainScheduledStateSpace","text":"GainScheduledStateSpace(systems, vt; interpolator, x_start = zeros((systems[1]).nx), name, u0 = zeros((systems[1]).nu), y0 = zeros((systems[1]).ny))\n\nA linear parameter-varying (LPV) version of Blocks.StateSpace, implementing the following equations:\n\nbeginaligned\ndotx = A(v) x + B(v) u \ny        = C(v) x + D(v) u\nendaligned\n\nwhere v is a scalar scheduling variable.\n\nArguments:\n\nsystems: A vector of ControlSystemsBase.StateSpace objects\nvt: A vector of breakpoint values for the scheduling variable v, this has the same length as systems.\ninterpolator: A constructor i = interpolator(values, breakpoints) and returns an interpolator object that can be called like i(v) to get the interpolated value at v. LinearInterpolation from DataInterpolations.jl is a good choice, but a lookup table can also be used.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemsMTK.batch_ss-Tuple","page":"API","title":"ControlSystemsMTK.batch_ss","text":"batch_ss(sys, inputs, outputs, ops::AbstractVector{<:AbstractDict};\n            t = 0.0,\n            allow_input_derivatives = false,\n            zero_dummy_der = false,\n            kwargs...)\n\nLinearize sys in multiple operating points ops::Vector{Dict}. Returns a vector of StateSpace objects and the simplified system.\n\nExample:\n\nusing ControlSystemsMTK, ModelingToolkit, RobustAndOptimalControl\nusing ModelingToolkit: getdefault\nunsafe_comparisons(true)\n\n# Create a model\n@parameters t k=10 k3=2 c=1\n@variables x(t)=0 [bounds = (-2, 2)]\n@variables v(t)=0\n@variables u(t)=0\n@variables y(t)=0\n\nD = Differential(t)\n\neqs = [D(x) ~ v\n       D(v) ~ -k * x - k3 * x^3 - c * v + 10u\n       y ~ x]\n\n\n@named duffing = ODESystem(eqs, t)\n\nbounds = getbounds(duffing, states(duffing))\nsample_within_bounds((l, u)) = (u - l) * rand() + l\n# Create a vector of operating points\nops = map(1:N) do i\n    op = Dict(x => sample_within_bounds(bounds[x]) for x in keys(bounds) if isfinite(bounds[x][1]))\nend\n\n\nPs, ssys = batch_ss(duffing, [u], [y], ops)\nw = exp10.(LinRange(-2, 2, 200))\nbodeplot(Ps, w)\nP = RobustAndOptimalControl.ss2particles(Ps) # convert to a single StateSpace system with `Particles` as coefficients.\nbodeplot(P, w) # Should look similar to the one above\n\nLet's also do some tuning for the linearized models above\n\nfunction batch_tune(f, Ps)\n    f.(Ps)\nend\n\nCs = batch_tune(Ps) do P\n    # C, kp, ki, fig, CF = loopshapingPI(P, 6; phasemargin=45)\n    C, kp, ki, kd, fig, CF = loopshapingPID(P, 6; Mt=1.3, Tf = 1/100)\n    ss(CF)\nend\n\nP = RobustAndOptimalControl.ss2particles(Ps)\nC = RobustAndOptimalControl.ss2particles(Cs)\n\nnyquistplot(P * C,\n            w,\n            ylims = (-10, 3),\n            xlims = (-5, 10),\n            points = true,\n            Ms_circles = [1.5, 2],\n            Mt_circles = [1.5, 2])\n\n# Fit circles that encircles the Nyquist curve for each frequency\ncenters, radii = fit_complex_perturbations(P * C, w; relative = false, nominal = :center)\nnyquistcircles!(w, centers, radii, ylims = (-4, 1), xlims = (-3, 4))\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemsMTK.build_quadratic_cost_matrix-Tuple{NamedTuple, ODESystem, AbstractVector{<:Pair}}","page":"API","title":"ControlSystemsMTK.build_quadratic_cost_matrix","text":"build_quadratic_cost_matrix(linear_sys, ssys::ODESystem, costs::Vector{Pair})\n\nFor a system that has been linearized, assemble a quadratic cost matrix (for LQR or Kalman filtering) that penalizes states or outputs of simplified system ssys accoring to the vector of pairs costs.\n\nThe motivation for this function is that ModelingToolkit does not guarantee\n\nWhich states are selected as states after simplification.\nThe order of the states.\n\nThe second problem above, the ordering of the states, can be worked around using reorder_states, but the first problem cannot be solved by trivial reordering. This function thus accepts an array of costs for a user-selected state realization, and assembles the correct cost matrix for the state realization selected by MTK. To do this, the funciton needs the linearization (linear_sys) as well as the simplified system, both of which are outputs of linearize.\n\nArguments:\n\nlinear_sys: Output of linearize, an object containing a property called C. This can be a ControlSystemsBase.StateSpace or a NamedTuple with a field C.\nssys: Output of linearize.\ncosts: A vector of pairs\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemsMTK.build_quadratic_cost_matrix-Tuple{ODESystem, AbstractVector, AbstractVector{<:Pair}}","page":"API","title":"ControlSystemsMTK.build_quadratic_cost_matrix","text":"build_quadratic_cost_matrix(sys::ODESystem, inputs::Vector, costs::Vector{Pair}; kwargs...)\n\nAssemble a quadratic cost matrix (for LQR or Kalman filtering) that penalizes states or outputs of system sys accoring to the vector of pairs costs.\n\nThe motivation for this function is that ModelingToolkit does not guarantee\n\nWhich states are selected as states after simplification.\nThe order of the states.\n\nThe second problem above, the ordering of the states, can be worked around using reorder_states, but the first problem cannot be solved by trivial reordering. This function thus accepts an array of costs for a user-selected state realization, and assembles the correct cost matrix for the state realization selected by MTK. To do this, the funciton performs a linearization between inputs and the cost outputs. The linearization is used to determine the matrix entries belonging to states that are not part of the realization chosen by MTK.\n\nArguments:\n\nsys: The system to be linearized (not simplified).\ninputs: A vector of variables that are to be considered controlled inputs for the LQR controller.\ncosts: A vector of pairs.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemsMTK.sconnect-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractTimeDependentSystem","page":"API","title":"ControlSystemsMTK.sconnect","text":"sconnect(sys1::T, sys2::T; name)\n\nConnect systems in series, equivalent to sys2*sys1 or series(sys1, sys2) in ControlSystems.jl terminology\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemsMTK.sconnect-Union{Tuple{T}, Tuple{Union{Function, Num}, T}} where T<:AbstractTimeDependentSystem","page":"API","title":"ControlSystemsMTK.sconnect","text":"sconnect(input::Function, sys::T; name)\nsconnect(input::Num,      sys::T; name)\n\nConnect a function input(t) to sys.input\n\nExamples:\n\nsconnect(sin, sys)   # Connect a funciton, assumed to be a function of time\nsconnect(sin(t), sys) # Connect a Num\n\n\n\n\n\n","category":"method"},{"location":"api/#RobustAndOptimalControl.named_ss-Tuple{AbstractTimeDependentSystem, Any, Any}","page":"API","title":"RobustAndOptimalControl.named_ss","text":"RobustAndOptimalControl.named_ss(sys::ModelingToolkit.AbstractTimeDependentSystem, inputs, outputs; kwargs...)\n\nConvert an ODESystem to a NamedStateSpace using linearization. inputs, outputs are vectors of variables determining the inputs and outputs respectively. See docstring of ModelingToolkit.linearize for more info on kwargs, reproduced below.\n\n(; A, B, C, D), simplified_sys = linearize(sys, inputs, outputs;    t=0.0, op = Dict(), allow_input_derivatives = false, kwargs...)\n(; A, B, C, D)                 = linearize(simplified_sys, lin_fun; t=0.0, op = Dict(), allow_input_derivatives = false)\n\nReturn a NamedTuple with the matrices of a linear statespace representation on the form\n\n$\n\n\\begin{aligned} ẋ &= Ax + Bu\\\ny &= Cx + Du \\end{aligned} $\n\nThe first signature automatically calls linearization_function internally, while the second signature expects the outputs of linearization_function as input.\n\nop denotes the operating point around which to linearize. If none is provided, the default values of sys are used.\n\nIf allow_input_derivatives = false, an error will be thrown if input derivatives (u) appear as inputs in the linearized equations. If input derivatives are allowed, the returned B matrix will be of double width, corresponding to the input [u; u̇].\n\nSee also linearization_function which provides a lower-level interface, and ModelingToolkit.reorder_states.\n\nSee extended help for an example.\n\nThe implementation and notation follows that of \"Linear Analysis Approach for Modelica Models\", Allain et al. 2009\n\nExtended help\n\nThis example builds the following feedback interconnection and linearizes it from the input of F to the output of P.\n\n\n  r ┌─────┐       ┌─────┐     ┌─────┐\n───►│     ├──────►│     │  u  │     │\n    │  F  │       │  C  ├────►│  P  │ y\n    └─────┘     ┌►│     │     │     ├─┬─►\n                │ └─────┘     └─────┘ │\n                │                     │\n                └─────────────────────┘\n\nusing ModelingToolkit\n@variables t\nfunction plant(; name)\n    @variables x(t) = 1\n    @variables u(t)=0 y(t)=0\n    D = Differential(t)\n    eqs = [D(x) ~ -x + u\n           y ~ x]\n    ODESystem(eqs, t; name = name)\nend\n\nfunction ref_filt(; name)\n    @variables x(t)=0 y(t)=0\n    @variables u(t)=0 [input=true]\n    D = Differential(t)\n    eqs = [D(x) ~ -2 * x + u\n           y ~ x]\n    ODESystem(eqs, t, name = name)\nend\n\nfunction controller(kp; name)\n    @variables y(t)=0 r(t)=0 u(t)=0\n    @parameters kp = kp\n    eqs = [\n        u ~ kp * (r - y),\n    ]\n    ODESystem(eqs, t; name = name)\nend\n\n@named f = ref_filt()\n@named c = controller(1)\n@named p = plant()\n\nconnections = [f.y ~ c.r # filtered reference to controller reference\n               c.u ~ p.u # controller output to plant input\n               p.y ~ c.y]\n\n@named cl = ODESystem(connections, t, systems = [f, c, p])\n\nlsys, ssys = linearize(cl, [f.u], [p.x])\ndesired_order =  [f.x, p.x]\nlsys = ModelingToolkit.reorder_states(lsys, states(ssys), desired_order)\n\n@assert lsys.A == [-2 0; 1 -2]\n@assert lsys.B == [1; 0;;]\n@assert lsys.C == [0 1]\n@assert lsys.D[] == 0\n\nModelingToolkit.linearize(sys, input_name::Symbol, output_name::Symbol; kwargs...)\n\nLinearize a system between two analysis points. To get a loop-transfer function, see get_looptransfer\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"bodeplot\nlinearize\nlinearization_function\nloopshapingPID\nnamed_ss\nModelingToolkitStandardLibrary.Blocks.get_looptransfer\nModelingToolkitStandardLibrary.Blocks.StateSpace\nRobustAndOptimalControl.ss2particles\nbodeplot\nControlSystemsBase.StateSpace\nSymbolicControlSystems.ccode\nSymbolicControlSystems.print_c_array\nModelingToolkit.reorder_states","category":"page"},{"location":"api/#ControlSystemsBase.bodeplot","page":"API","title":"ControlSystemsBase.bodeplot","text":"fig = bodeplot(sys, args...)\nbodeplot(LTISystem[sys1, sys2...], args...; plotphase=true, kwargs...)\n\nCreate a Bode plot of the LTISystem(s). A frequency vector w can be optionally provided. To change the Magnitude scale see setPlotScale(str)\n\nIf hz=true, the plot x-axis will be displayed in Hertz, the input frequency vector is still treated as rad/s.\n\nkwargs is sent as argument to RecipesBase.plot.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkit.linearize","page":"API","title":"ModelingToolkit.linearize","text":"ModelingToolkit.linearize(sys, input_name::Symbol, output_name::Symbol; kwargs...)\n\nLinearize a system between two analysis points. To get a loop-transfer function, see get_looptransfer\n\n\n\n\n\n(; A, B, C, D), simplified_sys = linearize(sys, inputs, outputs;    t=0.0, op = Dict(), allow_input_derivatives = false, kwargs...)\n(; A, B, C, D)                 = linearize(simplified_sys, lin_fun; t=0.0, op = Dict(), allow_input_derivatives = false)\n\nReturn a NamedTuple with the matrices of a linear statespace representation on the form\n\nbeginaligned\nx = Ax + Bu\ny = Cx + Du\nendaligned\n\nThe first signature automatically calls linearization_function internally, while the second signature expects the outputs of linearization_function as input.\n\nop denotes the operating point around which to linearize. If none is provided, the default values of sys are used.\n\nIf allow_input_derivatives = false, an error will be thrown if input derivatives (u) appear as inputs in the linearized equations. If input derivatives are allowed, the returned B matrix will be of double width, corresponding to the input [u; u̇].\n\nSee also linearization_function which provides a lower-level interface, and ModelingToolkit.reorder_states.\n\nSee extended help for an example.\n\nThe implementation and notation follows that of \"Linear Analysis Approach for Modelica Models\", Allain et al. 2009\n\nExtended help\n\nThis example builds the following feedback interconnection and linearizes it from the input of F to the output of P.\n\n\n  r ┌─────┐       ┌─────┐     ┌─────┐\n───►│     ├──────►│     │  u  │     │\n    │  F  │       │  C  ├────►│  P  │ y\n    └─────┘     ┌►│     │     │     ├─┬─►\n                │ └─────┘     └─────┘ │\n                │                     │\n                └─────────────────────┘\n\nusing ModelingToolkit\n@variables t\nfunction plant(; name)\n    @variables x(t) = 1\n    @variables u(t)=0 y(t)=0\n    D = Differential(t)\n    eqs = [D(x) ~ -x + u\n           y ~ x]\n    ODESystem(eqs, t; name = name)\nend\n\nfunction ref_filt(; name)\n    @variables x(t)=0 y(t)=0\n    @variables u(t)=0 [input=true]\n    D = Differential(t)\n    eqs = [D(x) ~ -2 * x + u\n           y ~ x]\n    ODESystem(eqs, t, name = name)\nend\n\nfunction controller(kp; name)\n    @variables y(t)=0 r(t)=0 u(t)=0\n    @parameters kp = kp\n    eqs = [\n        u ~ kp * (r - y),\n    ]\n    ODESystem(eqs, t; name = name)\nend\n\n@named f = ref_filt()\n@named c = controller(1)\n@named p = plant()\n\nconnections = [f.y ~ c.r # filtered reference to controller reference\n               c.u ~ p.u # controller output to plant input\n               p.y ~ c.y]\n\n@named cl = ODESystem(connections, t, systems = [f, c, p])\n\nlsys, ssys = linearize(cl, [f.u], [p.x])\ndesired_order =  [f.x, p.x]\nlsys = ModelingToolkit.reorder_states(lsys, states(ssys), desired_order)\n\n@assert lsys.A == [-2 0; 1 -2]\n@assert lsys.B == [1; 0;;]\n@assert lsys.C == [0 1]\n@assert lsys.D[] == 0\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkit.linearization_function","page":"API","title":"ModelingToolkit.linearization_function","text":"lin_fun, simplified_sys = linearization_function(sys::AbstractSystem, inputs, outputs; simplify = false, kwargs...)\n\nReturn a function that linearizes the system sys. The function linearize provides a higher-level and easier to use interface.\n\nlin_fun is a function (variables, p, t) -> (; f_x, f_z, g_x, g_z, f_u, g_u, h_x, h_z, h_u), i.e., it returns a NamedTuple with the Jacobians of f,g,h for the nonlinear sys (technically for simplified_sys) on the form\n\nbeginaligned\nx = f(x z u) \n0 = g(x z u) \ny = h(x z u)\nendaligned\n\nwhere x are differential states, z algebraic states, u inputs and y outputs. To obtain a linear statespace representation, see linearize. The input argument variables is a vector defining the operating point, corresponding to states(simplified_sys) and p is a vector corresponding to the parameters of simplified_sys. Note: all variables in inputs have been converted to parameters in simplified_sys.\n\nThe simplified_sys has undergone structural_simplify and had any occurring input or output variables replaced with the variables provided in arguments inputs and outputs. The states of this system also indicate the order of the states that holds for the linearized matrices.\n\nArguments:\n\nsys: An ODESystem. This function will automatically apply simplification passes on sys and return the resulting simplified_sys.\ninputs: A vector of variables that indicate the inputs of the linearized input-output model.\noutputs: A vector of variables that indicate the outputs of the linearized input-output model.\nsimplify: Apply simplification in tearing.\nkwargs: Are passed on to find_solvables!\n\nSee also linearize which provides a higher-level interface.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemsBase.loopshapingPID","page":"API","title":"ControlSystemsBase.loopshapingPID","text":"C, kp, ki, kd, fig, CF = loopshapingPID(P, ω; Mt = 1.3, ϕt=75, form=:standard, doplot=false, lb=-10, ub=10, Tf = 1/1000ω, F = nothing)\n\nSelects the parameters of a PID-controller such that the Nyquist curve of the loop-transfer function L = PC at the frequency ω is tangent to the circle where the magnitude of T = PC  (1+PC) equals Mt. ϕt denotes the positive angle in degrees between the real axis and the tangent point.\n\nThe default values for Mt and ϕt are chosen to give a good design for processes with inertia, and may need tuning for simpler processes.\n\nThe gain of the resulting controller is generally increasing with increasing ω and Mt.\n\nArguments:\n\nP: A SISO plant.\nω: The specification frequency.\nMt: The magnitude of the complementary sensitivity function at the specification frequency, T(iω).\nϕt: The \ndoplot: If true, gang of four and Nyquist plots will be returned in fig.\nlb: log10 of lower bound for kd.\nub: log10 of upper bound for kd.\nTf: Time constant for second-order measurement noise filter on the form tf(1, [Tf^2, 2*Tf/sqrt(2), 1]) to make the controller strictly proper. A practical controller typically sets this time constant slower than the default, e.g., Tf = 1/100ω or Tf = 1/10ω\nF: A pre-designed filter to use instead of the default second-order filter.\n\nThe parameters can be returned as one of several common representations  chosen by form, the options are\n\n:standard - K_p(1 + 1(T_i s) + T_ds)\n:series - K_c(1 + 1(τ_i s))(τ_d s + 1)\n:parallel - K_p + K_is + K_d s\n\nSee also loopshapingPI, pidplots, stabregionPID and placePI.\n\nExample:\n\nP  = tf(1, [1,0,0]) # A double integrator\nMt = 1.3  # Maximum magnitude of complementary sensitivity\nω  = 1    # Frequency at which the specification holds\nC, kp, ki, kd, fig, CF = loopshapingPID(P, ω; Mt, ϕt = 75, doplot=true)\n\n\n\n\n\n","category":"function"},{"location":"api/#RobustAndOptimalControl.named_ss","page":"API","title":"RobustAndOptimalControl.named_ss","text":"named_ss(sys::AbstractStateSpace{T}; x, u, y)\n\nCreate a NamedStateSpace system. This kind of system uses names rather than integer indices to refer to states, inputs and outputs.\n\nIf a single name is provided but a vector of names is expected, this name will be used as prefix followed by a numerical index.\nIf no name is provided, default names (x,y,u) will be used.\n\nArguments:\n\nsys: A system to add names to.\nx: A list of symbols with names of the states.\nu: A list of symbols with names of the inputs.\ny: A list of symbols with names of the outputs.\n\nExample\n\nG1 = ss(1,1,1,0)\nG2 = ss(1,1,1,0)\ns1 = named_ss(G1, x = :x, u = :u1, y=:y1)\ns2 = named_ss(G2, x = :z, u = :u2, y=:y2)\n\ns1[:y1, :u1] # Index using symbols. Uses prefix matching if no exact match is found.\n\nfb = feedback(s1, s2, r = :r) # \n\n\n\n\n\nnamed_ss(sys::AbstractStateSpace, name; x, y, u)\n\nIf a single name of the system is provided, the outputs, inputs and states will be automatically named y,u,x with name as prefix.\n\n\n\n\n\nnamed_ss(sys::ExtendedStateSpace;       kwargs...)\nnamed_ss(sys::ExtendedStateSpace, name; kwargs...)\n\nAssign names to an ExtendedStateSpace. If no specific names are provided for signals z,y,w,u and statesx, names will be generated automatically.\n\nArguments:\n\nname: Prefix to add to all automatically generated names.\nx\nu\ny\nw\nz\n\n\n\n\n\nRobustAndOptimalControl.named_ss(sys::ModelingToolkit.AbstractTimeDependentSystem, inputs, outputs; kwargs...)\n\nConvert an ODESystem to a NamedStateSpace using linearization. inputs, outputs are vectors of variables determining the inputs and outputs respectively. See docstring of ModelingToolkit.linearize for more info on kwargs, reproduced below.\n\n(; A, B, C, D), simplified_sys = linearize(sys, inputs, outputs;    t=0.0, op = Dict(), allow_input_derivatives = false, kwargs...)\n(; A, B, C, D)                 = linearize(simplified_sys, lin_fun; t=0.0, op = Dict(), allow_input_derivatives = false)\n\nReturn a NamedTuple with the matrices of a linear statespace representation on the form\n\n$\n\n\\begin{aligned} ẋ &= Ax + Bu\\\ny &= Cx + Du \\end{aligned} $\n\nThe first signature automatically calls linearization_function internally, while the second signature expects the outputs of linearization_function as input.\n\nop denotes the operating point around which to linearize. If none is provided, the default values of sys are used.\n\nIf allow_input_derivatives = false, an error will be thrown if input derivatives (u) appear as inputs in the linearized equations. If input derivatives are allowed, the returned B matrix will be of double width, corresponding to the input [u; u̇].\n\nSee also linearization_function which provides a lower-level interface, and ModelingToolkit.reorder_states.\n\nSee extended help for an example.\n\nThe implementation and notation follows that of \"Linear Analysis Approach for Modelica Models\", Allain et al. 2009\n\nExtended help\n\nThis example builds the following feedback interconnection and linearizes it from the input of F to the output of P.\n\n\n  r ┌─────┐       ┌─────┐     ┌─────┐\n───►│     ├──────►│     │  u  │     │\n    │  F  │       │  C  ├────►│  P  │ y\n    └─────┘     ┌►│     │     │     ├─┬─►\n                │ └─────┘     └─────┘ │\n                │                     │\n                └─────────────────────┘\n\nusing ModelingToolkit\n@variables t\nfunction plant(; name)\n    @variables x(t) = 1\n    @variables u(t)=0 y(t)=0\n    D = Differential(t)\n    eqs = [D(x) ~ -x + u\n           y ~ x]\n    ODESystem(eqs, t; name = name)\nend\n\nfunction ref_filt(; name)\n    @variables x(t)=0 y(t)=0\n    @variables u(t)=0 [input=true]\n    D = Differential(t)\n    eqs = [D(x) ~ -2 * x + u\n           y ~ x]\n    ODESystem(eqs, t, name = name)\nend\n\nfunction controller(kp; name)\n    @variables y(t)=0 r(t)=0 u(t)=0\n    @parameters kp = kp\n    eqs = [\n        u ~ kp * (r - y),\n    ]\n    ODESystem(eqs, t; name = name)\nend\n\n@named f = ref_filt()\n@named c = controller(1)\n@named p = plant()\n\nconnections = [f.y ~ c.r # filtered reference to controller reference\n               c.u ~ p.u # controller output to plant input\n               p.y ~ c.y]\n\n@named cl = ODESystem(connections, t, systems = [f, c, p])\n\nlsys, ssys = linearize(cl, [f.u], [p.x])\ndesired_order =  [f.x, p.x]\nlsys = ModelingToolkit.reorder_states(lsys, states(ssys), desired_order)\n\n@assert lsys.A == [-2 0; 1 -2]\n@assert lsys.B == [1; 0;;]\n@assert lsys.C == [0 1]\n@assert lsys.D[] == 0\n\nModelingToolkit.linearize(sys, input_name::Symbol, output_name::Symbol; kwargs...)\n\nLinearize a system between two analysis points. To get a loop-transfer function, see get_looptransfer\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkitStandardLibrary.Blocks.get_looptransfer","page":"API","title":"ModelingToolkitStandardLibrary.Blocks.get_looptransfer","text":"get_looptransfer(sys, ap::AnalysisPoint; kwargs)\nget_looptransfer(sys, ap_name::Symbol; kwargs)\n\nCompute the (linearized) loop-transfer function in analysis point ap, from ap.out to ap.in.\n\ndanger: Experimental\nThe analysis-point interface is currently experimental and at any time subject to breaking changes not respecting semantic versioning.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_comp_sensitivity, open_loop.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkitStandardLibrary.Blocks.StateSpace","page":"API","title":"ModelingToolkitStandardLibrary.Blocks.StateSpace","text":"StateSpace(A, B, C, D=0; x_start=zeros(size(A,1)), u0=zeros(size(B,2)), y0=zeros(size(C,1)), name)\n\nA linear, time-invariant state-space system on the form.\n\nx = Ax + Bu\ny = Cx + Du\n\nTransfer functions can also be simulated by converting them to a StateSpace form.\n\ny0 and u0 can be used to set an operating point, providing them changes the dynamics from an LTI system to the affine system \n\nx = Ax + B(u - u0)\ny = Cx + D(u - u0) + y0\n\nFor a nonlinear system\n\nx = f(x u)\ny = h(x u)\n\nlinearized around the operating point x₀, u₀, we have y0, u0 = h(x₀, u₀), u₀.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicControlSystems.ccode","page":"API","title":"SymbolicControlSystems.ccode","text":"ccode(G; simplify = identity, cse = true)\n\nReturn a string with C-code for filtering a signal u through G. \n\nArguments:\n\nG: A linear system\nsimplify: A function for symbolic simplification. You may try Sympy.simplify, but for large systems, this will take a long time to compute.\ncse: Perform common subexpression elimination. This generally improvems the performance of the generated code.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicControlSystems.print_c_array","page":"API","title":"SymbolicControlSystems.print_c_array","text":"print_c_array(io, a::Vector{<:AbstractArray}, t::AbstractVector, name = \"mat\"; cse = false, s = \"\", print_vector = true, print_logic = true, struct_name::Union{Nothing, String} = nothing, struct_type = nothing, ivecname = name * \"_interp_vect\")\n\nWrite C-code for interpolating between arrays a. The array t contains the interpolation points.\n\n\n\n\n\nprint_c_array(io, sys::Vector{<:AbstractStateSpace}, t::AbstractVector, name = \"sys\"; cse = false, s = \"\", en = \"\", struct_name::Union{Nothing, String} = nothing, struct_type = nothing)\n\nWrite C-code for an interpolated linear system. The interpolation vector t defines the interpolation points, this vector is expected to be of the same length as the vector of linear systems sys. \n\ns, en: are strings that are appended at the start and end of variables names in the C-code.\nstruct_name: If provided, the interpolation matrices will be placed inside a struct with this name.\nstruct_type: If the struct name is used, provide also the C type of the struct.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkit.reorder_states","page":"API","title":"ModelingToolkit.reorder_states","text":"reorder_states(sys::NamedTuple, old, new)\n\nPermute the state representation of sys obtained from linearize so that the state order is changed from old to new Example:\n\nlsys, ssys = linearize(pid, [reference.u, measurement.u], [ctr_output.u])\ndesired_order = [int.x, der.x] # States that are present in states(ssys)\nlsys = ModelingToolkit.reorder_states(lsys, states(ssys), desired_order)\n\nSee also ModelingToolkit.similarity_transform\n\n\n\n\n\n","category":"function"},{"location":"batch_linearization/#Batch-Linearization-and-gain-scheduling","page":"Batch linearization and gain scheduling","title":"Batch Linearization and gain scheduling","text":"","category":"section"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"This example will demonstrate how to linearize a nonlinear ModelingToolkit model in multiple different operating points, and some tools to work with groups of linear models representing the same system in different operating points. We'll end with designing and simulating a gain-scheduled controller, i.e., a nonlinear controller created as an interpolation between linear controllers.","category":"page"},{"location":"batch_linearization/#System-model","page":"Batch linearization and gain scheduling","title":"System model","text":"","category":"section"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"The model will be a simple Duffing oscillator:","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"using ControlSystemsMTK, ModelingToolkit, MonteCarloMeasurements, ModelingToolkitStandardLibrary.Blocks\nusing ModelingToolkit: getdefault\nunsafe_comparisons(true)\n\n# Create a model\n@parameters t k=10 k3=2 c=1\n@variables x(t)=0 [bounds = (-0.5, 1.5)]\n@variables v(t)=0\n\nD = Differential(t)\n\n@named y = Blocks.RealOutput()\n@named u = Blocks.RealInput()\n\neqs = [D(x) ~ v\n       D(v) ~ -k * x - k3 * x^3 - c * v + 10u.u\n       y.u ~ x]\n\n\n@named duffing = ODESystem(eqs, t, systems=[y, u])","category":"page"},{"location":"batch_linearization/#Batch-linearization","page":"Batch linearization and gain scheduling","title":"Batch linearization","text":"","category":"section"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"To perform batch linearization, we create a vector of operating points, and then linearize the model around each of these points. The function batch_ss does this for us, and returns a vector of StateSpace models, one for each operating point. An operating point is a Dict that maps variables in the MTK model to numerical values. In the example below, we simply sample the variables uniformly within their bounds specified when we created the variables (normally, we might want to linearize on stationary points)","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"N = 16 # Number of samples\nxs = range(getbounds(x)[1], getbounds(x)[2], length=N)\nops = Dict.(x .=> xs)","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Just like ModelingToolkit.linearize, batch_ss takes the set of inputs and the set of outputs to linearize between.","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Ps, ssys = batch_ss(duffing, [u.u], [y.u], ops)\nnothing # hide","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Plotting functions like bodeplot accept vectors of systems, so this works","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"using ControlSystemsBase, Plots\nw = exp10.(LinRange(-2, 3, 200))\nbodeplot(Ps, w, legend=false)","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"We can also convert the vector of system models to a single model with RobustAndOptimalControl.ss2particles, which will convert the coefficients of the state space models to MonteCarloMeasurements.Particles objects.","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"using RobustAndOptimalControl\nP = RobustAndOptimalControl.ss2particles(Ps) # convert to a single StateSpace system with `Particles` as coefficients.","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"notice how some coefficients are plotted like uncertain numbers -13.8 ± 4.3. We can plot such models as well:","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"bodeplot(P, w, legend=:bottomright) # Should look similar to the one above","category":"page"},{"location":"batch_linearization/#Controller-tuning","page":"Batch linearization and gain scheduling","title":"Controller tuning","text":"","category":"section"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Let's also do some controller tuning for the linearized models above. The function batch_tune is not really required here, but it shows how we might go about building more sophisticated tools for batch tuning. In this example, we will tune a PID controller using the function loopshapingPID.","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"function batch_tune(f, Ps)\n    f.(Ps)\nend\n\nCs = batch_tune(Ps) do P\n    C, kp, ki, kd, fig, CF = loopshapingPID(P, 7; Mt=1.2, Tf = 1/100)\n    ss(CF)\nend\n\nP = RobustAndOptimalControl.ss2particles(Ps)\nC = RobustAndOptimalControl.ss2particles(Cs)\n\nnyquistplot(P * C,\n            w,\n            ylims = (-10, 2),\n            xlims = (-8, 5),\n            points = true,\n            Ms_circles = [1.5, 2],\n            Mt_circles = [1.2])","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Above, we plotted the Nyquist curve of the loop-transfer function for all system realizations. RobustAndOptimalControl.jl has some facilities for fitting circles around the Nyquist curve for uncertain systems, which we could use here:","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"centers, radii = fit_complex_perturbations(P * C, w; relative = false, nominal = :center)\nnyquistcircles!(w, centers, radii, ylims = (-5, 1), xlims = (-3, 4))","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"some methods for robust control operate on such circles. Notice how the circles are conservative in many cases, this is typically due to the gain varying between the models for the same phase.","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"If you plot the Nyquist curve using the plotly() backend rather than the default gr() backend used here, you can hover the mouse over the curves and see which frequency they correspond to etc. ","category":"page"},{"location":"batch_linearization/#Gain-scheduling","page":"Batch linearization and gain scheduling","title":"Gain scheduling","text":"","category":"section"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Above, we tuned one controller for each operating point, wouldn't it be nice if we had some features to simulate a gain-scheduled controller that interpolates between the different controllers depending on the operating pont? GainScheduledStateSpace is such a thing, we show how to use it below. For fun, we simulate some reference step responses for each individual controller in the array Cs and end with simulating the gain-scheduled controller.","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"using OrdinaryDiffEq\nusing DataInterpolations # Required to interpolate between the controllers\n@named fb  = Blocks.Add(k2=-1)\n@named ref = Blocks.Square(frequency=1/6, amplitude=0.5, offset=0.5, start_time=1)\n@named F   = Blocks.SecondOrder(w=15, d=1) # A reference pre-filter\nconnect    = ModelingToolkit.connect\n\nclosed_loop_eqs = [\n    connect(ref.output, F.input)\n    connect(F.output, fb.input1)\n    connect(duffing.y, fb.input2)\n]\nplot(layout=2)\n\n# Simulate each individual controller\nfor C in Cs\n    @named Ci = ODESystem(C)\n    eqs = [\n        closed_loop_eqs\n        connect(fb.output, Ci.input)\n        connect(Ci.output, duffing.u)\n    ]\n    @named closed_loop = ODESystem(eqs, t, systems=[duffing, Ci, fb, ref, F])\n    prob = ODEProblem(structural_simplify(closed_loop), [], (0.0, 8.0))\n    sol = solve(prob, Rodas5P(), abstol=1e-8, reltol=1e-8)\n    plot!(sol, idxs=[duffing.y.u, duffing.u.u], layout=2, lab=\"\")\nend\n\n# Simulate gain-scheduled controller\n@named Cgs = GainScheduledStateSpace(Cs, xs, interpolator=LinearInterpolation)\neqs = [\n    closed_loop_eqs\n    connect(fb.output, Cgs.input)\n    connect(Cgs.output, duffing.u)\n    connect(duffing.y, Cgs.scheduling_input) # Don't forget to connect the scheduling variable!\n]\n@named closed_loop = ODESystem(eqs, t, systems=[duffing, Cgs, fb, ref, F])\nprob = ODEProblem(structural_simplify(closed_loop), [], (0.0, 8.0))\nsol = solve(prob, Rodas5P(), abstol=1e-8, reltol=1e-8)\nplot!(sol, idxs=[duffing.y.u, duffing.u.u], l=(2, :red), lab=\"Gain scheduled\")\nplot!(sol, idxs=F.output.u, l=(1, :black, :dash, 0.5), lab=\"Ref\")","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"If everything worked as expected, the gain-scheduled controller should perform better than each of the included controllers individually. ","category":"page"},{"location":"batch_linearization/#C-Code-generation","page":"Batch linearization and gain scheduling","title":"C-Code generation","text":"","category":"section"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"We can generate C-code to interpolate our controller using the function SymbolicControlSystems.print_c_array from SymbolicControlSystems.jl. If the controller is a standard ControlSystemsBase.StateSpace object, a function that filters the input through the controller can be generated by calling SymbolicControlSystems.ccode. But if the controller is a vector of controllers representing a gain-scheduled controller, a function that creates the interpolated dynamics is written. In the code below, we shorten the vector of controllers to make the generated C-code easier to read by passing Cs[1:7:end] and xs[1:7:end]","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"using SymbolicControlSystems, ControlSystemsBase\nCs_disc = c2d.(Cs, 0.05, :tustin) # Discretize the controller before generating code\ncode = SymbolicControlSystems.print_c_array(stdout, Cs_disc[1:7:end], xs[1:7:end], \"Cs\")","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"The generated code starts by defining the interpolation vector xs, this variable is called Cs_interp_vect in the generated code. The code then defines all the A matrices as a 3-dimensional array, followed by a function that performs the interpolation interpolate_Cs_A. This function takes the output array as the first argument, a pointer to the 3D array with interpolation matrices, the interpolation vector as well as the interpolation variable t, in this document called v. The same code is then repeated for the matrices BCD as well if they require interpolation (if they are all the same, no interpolation code is written). ","category":"page"},{"location":"batch_linearization/#Summary","page":"Batch linearization and gain scheduling","title":"Summary","text":"","category":"section"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"We have seen how to","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Perform linearization of a nonlinear ModelingToolkit model in multiple different operating points\nHandle arrays of models or models with Particles as coefficients\nSimulate a gain-scheduled controller that interpolates between linear controllers\nWrite C-code to perform the interpolation of the controllers","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Batch linearization in multiple different operating points is an intuitive way to perform analysis of a nonlinear control system. Gain-scheduling is an equally intuitive way of realizing a nonlinear controller. Care should be taken to ensure that the scheduling variable does not change too fast such that the linear assumption at each instance of time is not violated.","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"using Test\n@test sol(6.99, idxs=closed_loop.duffing.y.u) ≈ 0.0 atol=0.01","category":"page"},{"location":"#ControlSystemsMTK.jl","page":"Home","title":"ControlSystemsMTK.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ControlSystemsMTK provides an interface between ControlSystems.jl and ModelingToolkit.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the videos below for examples of using ControlSystems and ModelingToolkit together.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<iframe style=\"height: 315px; width: 560px\" src=\"https://www.youtube.com/embed/favQKOyyx4o\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<iframe style=\"height: 315px; width: 560px\" src=\"https://www.youtube.com/embed/Effifd9Th9I\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add ControlSystemsMTK","category":"page"},{"location":"#From-ControlSystems-to-ModelingToolkit","page":"Home","title":"From ControlSystems to ModelingToolkit","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simply calling ODESystem(sys) converts a StateSpace object from ControlSystems into the corresponding ModelingToolkitStandardLibrary.Blocks.StateSpace. If sys is a named statespace object, the names will be retained in the ODESystem.","category":"page"},{"location":"#Example:","page":"Home","title":"Example:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using ControlSystemsMTK, ControlSystemsBase, ModelingToolkit, RobustAndOptimalControl\n\njulia> P0 = tf(1.0, [1, 1])  |> ss\nStateSpace{Continuous, Float64}\nA = \n -1.0\nB = \n 1.0\nC = \n 1.0\nD = \n 0.0\n\nContinuous-time state-space model\n\njulia> @named P = ODESystem(P0)\nModel P with 2 equations\nStates (3):\n  x[1](t) [defaults to 0.0]\n  input₊u(t) [defaults to 0.0]\n  output₊u(t) [defaults to 0.0]\nParameters (0):\n\njulia> equations(P)\n2-element Vector{Equation}:\n Differential(t)(x[1](t)) ~ input₊u(t) - x[1](t)\n output₊u(t) ~ x[1](t)","category":"page"},{"location":"#From-ModelingToolkit-to-ControlSystems","page":"Home","title":"From ModelingToolkit to ControlSystems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An ODESystem can be converted to a named statespace object from RobustAndOptimalControl.jl by calling named_ss","category":"page"},{"location":"","page":"Home","title":"Home","text":"named_ss(ode_sys, inputs, outputs; op)","category":"page"},{"location":"","page":"Home","title":"Home","text":"this performs a linearization of ode_sys around the operating point op (defaults to the default values of all variables in ode_sys).","category":"page"},{"location":"#Example:-2","page":"Home","title":"Example:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Using P from above:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> @unpack input, output = P;\n\njulia> P02_named = named_ss(P, [input.u], [output.u])\nNamedStateSpace{Continuous, Float64}\nA = \n -1.0\nB = \n 1.0\nC = \n 1.0\nD = \n 0.0\n\nContinuous-time state-space model\nWith state  names: x[1](t)\n     input  names: input₊u(t)\n     output names: output₊u(t)\n\njulia> using Plots;\n\njulia> bodeplot(P02_named)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: plot)","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ss(P02_named) # Convert to a statespace system without names\nStateSpace{Continuous, Float64}\nA = \n -1.0\nB = \n 1.0\nC = \n 1.0\nD = \n 0.0\n\nContinuous-time state-space model","category":"page"},{"location":"","page":"Home","title":"Home","text":"ModelingToolkit tends to give weird names to inputs and outputs etc., to access variables easily, named_ss implements prefix matching, so that you can access the mapping from input₊u(t) to output₊u(t) by","category":"page"},{"location":"","page":"Home","title":"Home","text":"P02_named[:out, :in]","category":"page"},{"location":"","page":"Home","title":"Home","text":"To learn more about linearization of ModelingToolkit models, see the video below","category":"page"},{"location":"","page":"Home","title":"Home","text":"<iframe style=\"height: 315px; width: 560px\" src=\"https://www.youtube.com/embed/-XOux-2XDGI\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","category":"page"},{"location":"#Additional-resources","page":"Home","title":"Additional resources","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modeling for control using ModelingToolkit tutorial\nLinear Analysis tools in ModelingToolkit\nVideo demo using ControlSystems and MTK","category":"page"},{"location":"#Internals:-Transformation-of-non-proper-models-to-proper-statespace-form","page":"Home","title":"Internals: Transformation of non-proper models to proper statespace form","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For some models, ModelingToolkit will fail to produce a proper statespace model (a non-proper model is differentiating the inputs, i.e., it has a numerator degree higher than the denominator degree if represented as a transfer function) when calling linearize. For such models, given on the form dot x = Ax + Bu + bar B dot u we create the following augmented descriptor model","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nsX = Ax + BU + sbar B U \nX_u = U\ns(X - bar B X_u) = AX + BU \ns beginbmatrixI  -bar B  0  0 endbmatrix = \nbeginbmatrix A  0  0  -Iendbmatrix\nbeginbmatrixX  X_u endbmatrix + \nbeginbmatrix B  I_uendbmatrix U \nsE = A_e x_e + B_e u\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where X_u is a new algebraic state variable and I_u is a selector matrix that picks out the differentiated inputs appearing in dot u (if all inputs appear, I_u = I).","category":"page"},{"location":"","page":"Home","title":"Home","text":"This model may be converted to a proper statespace model (if the system is indeed proper) using DescriptorSystems.dss2ss. All of this is handled automatically by named_ss(sys).","category":"page"}]
}
